#!python

# Copyright (C) 2017, Shan Zhang, Weizhi Song and Torsten Thomas
# Shan Zhang <zzfanyi@gmail.com>
# Weizhi Song <songwz03@gmail.com>
# Torsten Thomas <t.thomas@unsw.edu.au>

# BioSAK is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.

# BioSAK is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Affero General Public License for more details.

# You should have received a copy of the GNU Affero General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

import sys
import warnings
import argparse
from BioSAK.BioSAK_config import config_dict


def version(config_dict):
    version_file = open('%s/VERSION' % config_dict['config_file_path'])
    return version_file.readline().strip()


def print_main_help():

    help_message = ''' 
                 ...::: BioSAK v%s :::...

    Genome databases
       get_GTDB_taxon_gnm      ->  Get id of genomes from specified GTDB taxons
       get_genome_GTDB         ->  Batch download GTDB genomes
       get_genome_NCBI         ->  Batch download GenBank genomes
       sampling_GTDB_gnms      ->  Select GTDB genomes
       subset_GTDB_meta        ->  Subset metadata of GTDB reference genomes
       metaAssembly            ->  Get metadata of NCBI assembly records
       metaBiosample           ->  Get metadata of NCBI biosample records
       statsTaxa               ->  stats GTDB taxa
       GenBank                 ->  get sequence/organism/voucher info

    Metagenomics
       metabat2concoct         ->  convert MetaBAT depth to CONCOCT depth
       metabat2maxbin          ->  convert MetaBAT depth to MaxBin depth
       CheckM                  ->  Parse CheckM outputs
       Plot_MAG                ->  plot MAGs, (GC vs depth)
       magabund                ->  Calculate MAG abundance
       mean_MAG_cov            ->  Get mean MAG depth (by MetaBAT depth)
       RunGraphMB              ->  Prepare input files for GraphMB
       gc                      ->  Get GC content
       get_gnm_size            ->  Get the total length of genome(s)
       get_gene_depth          ->  Get gene depth by contig depth
       MeanMappingDepth        ->  Get mean mapping depth 
       get_MAG_reads_long      ->  Extract MAG-specific long reads for reassembling
       mmseqs                  ->  Classify metagenomic contigs with mmseqs
       parse_mmseqs_tsv        ->  Parse mmseqs tsv
       fastaai                 ->  A wrapper for FastAAI
       abd                     ->  get MAG abundance across metagenomes (Wenxiu Wang et al. 2024)
       abd_mask                ->  prepare masked sequence for abd module
       
    Functional annotation
       KEGG                    ->  KEGG annotation
       koala                   ->  Separate the combined BlastKOALA or GhostKOALA output
       COG2020                 ->  COG annotation (v2020, by blastp/diamond)
       COG2024                 ->  COG annotation (v2024, by blastp/diamond)
       arCOG                   ->  COG annotation for archaea (version ar18)
       dbCAN                   ->  CAZy annotation with dbCAN
       Combine_KEGG_arCOG      ->  Combine KEGG and arCOG annotation results
       Combine_KEGG_COG        ->  Combine KEGG and COG annotation results
       enrich                  ->  Functional enrichment analysis
       gapseq                  ->  Data matrix GapSeq predicted pathways
       stats_ko                ->  get stats for a list of provided KO
       stats_cog2020           ->  get stats for a list of provided COG (to be added)
       stats_arcog             ->  get stats for a list of provided arCOG 

    16S rRNA related
       Usearch16S              ->  Usearch for Novogene 16S amplicon sequencing results
       blca                    ->  Classify 16S with BLCA
       top_16S_hits            ->  Classify 16S by top-blast-hits approach
       SILVA_for_BLCA          ->  Prepare BLCA-compatible SILVA SSU database
       GTDB_for_BLCA           ->  Prepare BLCA-compatible GTDB SSU database
       UNITE_for_BLCA          ->  Prepare BLCA-compatible UNITE SSU database
       BLCA_op_parser          ->  Make the BLCA outputs bit easier to read
       Tax4Fun2IndOTU          ->  Get functional profile for individual OTUs (to be added)
       get_eu_otu              ->  Get eukaryotic OTUs
       rm_low_abd_otu          ->  Remove low abd otu from table
       combine_low_abd_otu     ->  Combine low abundance OTUs
       rm_low_depth_sample     ->  Remove samples from OTU table with small number of sequences

    Sequence manipulator
       gbk2fna/gbk2faa/gbk2ffn ->  Format convertors
       ffn2faa/gfa2fa/get_rc   ->  Format convertors
       fq2fa                   ->  Convert fastq to fasta
       fa2id                   ->  Export sequence id
       slice_seq               ->  Get specified region of a sequence
       rename_seq              ->  Rename sequences in a file
       prefix_seq_by_file_name ->  prefix sequences by file name
       select_seq              ->  Select sequences by id
       split_fasta             ->  Split one fasta file into multiple files
       merge_seq               ->  Merge sequence files, remove duplicated ones if any
       cat_fa                  ->  Combine fasta files, prefix sequence id with file name
           
    Sam and Bam
       reads2bam               ->  Mapping and sorting
       sam2bam                 ->  Sam to BAM with samtools
       split_sam               ->  Split SAM/BAM file by reference
       bam2reads               ->  Extract reads (id) from sam file
       plot_sam_depth          ->  Plot SAM depth
    
    Dataframe and Statistics
       subset_df               ->  Subset dataframe
       merge_df                ->  Merge dataframes
       add_desc                ->  Add function description to input of the iTOL module
       transpose               ->  Transpose dataframe
       wilcox                  ->  Wilcoxon signed-rank test (non-parametric paired T-test)
       mannwhitneyu            ->  Mann-Whitney U rank test on two independent samples
    
    Others
       js_cmds                 ->  Put commands in job scripts
       js_hpc3                 ->  Put commands in job scripts (HKUST hpc3)
       hpc3                    ->  Submit jobs on HKUST hpc3
       srun                    ->  srun one-line commands on HKUST hpc3
       exe_cmds                ->  Execute commands with multiprocessing
       split_folder            ->  Split folder
       prefix_file             ->  Prefix file
       BestHit                 ->  Keep best blast hits (outfmt 6)
       VisGeneFlk              ->  Visualize gene flanking regions
       usearch_uc              ->  Parse Usearch uc file
       get_Pfam_hmms           ->  Get Pfam profiles by id
       Reads_simulator         ->  Simulate NGS reads
       SubsampleLongReads      ->  Subsample Long Reads
       rename_reads_Reago      ->  Rename paired reads for Reago
       cross_link_seqs         ->  Cross link matched regions between two sequences
       submitHPC               ->  A wrapper for submitHPC.sh
       KeepRemovingTmp         ->  Keep removing old files in a folder
       ribbon                  ->  Make a ribbon diagram
       compare_sets            ->  compare_sets
       sankey                  ->  get sankey plot
       sra                     ->  Download reads with sratoolkit
       vis_color_scheme        ->  Visualize color scheme
       trim                    ->  a wrapper for trimmomatic
       FasterqDump             ->  a wrapper for fasterq-dump
       rename_df_row           ->  rename row headers in a dataframe
       blast                   ->  Parse batch online blast output
       taxdump                 ->  Parse NCBI Taxonomy database

    1. Phylogenetic tree-related modules have been moved to TreeSAK
    2. Upgrade with: pip3 install --upgrade BioSAK

    ''' % version(config_dict)

    print(help_message)


if __name__ == '__main__':

    # initialize the options parser and disable warning message
    parser = argparse.ArgumentParser()
    subparsers = parser.add_subparsers(help="--", dest='subparser_name')
    warnings.filterwarnings('ignore')

    # parse options
    if (len(sys.argv) == 1) or (sys.argv[1] in ['-h', '-help', '--help']):
        print_main_help()
        exit()

    elif sys.argv[1] in ['iTOL', 'SliceMSA', 'ConvertMSA', 'fa2phy', 'PhyloBiAssoc', 'OneLineAln']:
        print('This module has moved to TreeSAK, please run "TreeSAK %s -h" instead, program exited!' % sys.argv[1])
        exit()

    elif sys.argv[1] == 'COG2020':
        from BioSAK import COG2020
        COG2020_parser = subparsers.add_parser('COG2020', description='Wrapper for COG annotation (v2020)', usage=COG2020.COG2020_parser_usage)
        COG2020_parser.add_argument('-i',                   required=True,                                  help='path to input sequences (in multi-fasta format)')
        COG2020_parser.add_argument('-x',                   required=False,                                 help='file extension')
        COG2020_parser.add_argument('-m',                   required=True,                                  help='sequence type, "N/n" for "nucleotide", "P/p" for "protein"')
        COG2020_parser.add_argument('-d',                   required=False, default=None,                   help='gene depth file/folder')
        COG2020_parser.add_argument('-pct_by_all',          required=False, action='store_true',            help='normalize by all query genes, rather than those with COG assignment')
        COG2020_parser.add_argument('-db_dir',              required=True,                                  help='DB folder')
        COG2020_parser.add_argument('-diamond',             required=False, action='store_true',            help='run diamond (for big dataset), default is NCBI blastp')
        COG2020_parser.add_argument('-t',                   required=False, default=1,     type=int,        help='number of threads')
        COG2020_parser.add_argument('-evalue',              required=False, default=0.001, type=float,      help='evalue cutoff, default: 0.001')
        args = vars(parser.parse_args())
        COG2020.COG2020(args)

    elif sys.argv[1] == 'COG2024':
        from BioSAK import COG2024
        COG2024_parser = subparsers.add_parser('COG2024', description='Wrapper for COG annotation (v2024)', usage=COG2024.COG2024_parser_usage)
        COG2024_parser.add_argument('-i',                   required=True,                                  help='path to input sequences (in multi-fasta format)')
        COG2024_parser.add_argument('-x',                   required=False,                                 help='file extension')
        COG2024_parser.add_argument('-m',                   required=True,                                  help='sequence type, "N/n" for "nucleotide", "P/p" for "protein"')
        COG2024_parser.add_argument('-d',                   required=False, default=None,                   help='gene depth file/folder')
        COG2024_parser.add_argument('-pct_by_all',          required=False, action='store_true',            help='normalize by all query genes, rather than those with COG assignment')
        COG2024_parser.add_argument('-db_dir',              required=True,                                  help='DB folder')
        COG2024_parser.add_argument('-diamond',             required=False, action='store_true',            help='run diamond (for big dataset), default is NCBI blastp')
        COG2024_parser.add_argument('-t',                   required=False, default=1,     type=int,        help='number of threads')
        COG2024_parser.add_argument('-evalue',              required=False, default=0.001, type=float,      help='evalue cutoff, default: 0.001')
        args = vars(parser.parse_args())
        COG2024.COG2024(args)

    elif sys.argv[1] == 'arCOG':
        from BioSAK import arCOG
        arCOG_parser = subparsers.add_parser('arCOG', description='Wrapper for arCOG', usage=arCOG.arCOG_parser_usage)
        arCOG_parser.add_argument('-i',                   required=True,                                  help='path to input sequences (in multi-fasta format)')
        arCOG_parser.add_argument('-o',                   required=True,                                  help='output directory')
        arCOG_parser.add_argument('-x',                   required=False,                                 help='file extension')
        arCOG_parser.add_argument('-m',                   required=True,                                  help='sequence type, "N/n" for "nucleotide", "P/p" for "protein"')
        arCOG_parser.add_argument('-d',                   required=False, default=None,                   help='gene depth file/folder')
        arCOG_parser.add_argument('-pct_by_all',          required=False, action='store_true',            help='normalize by all query genes, rather than those with COG assignment')
        arCOG_parser.add_argument('-db_dir',              required=True,                                  help='DB folder')
        arCOG_parser.add_argument('-diamond',             required=False, action='store_true',            help='run diamond (for big dataset), default is NCBI blastp')
        arCOG_parser.add_argument('-t',                   required=False, default=1,     type=int,        help='number of threads')
        arCOG_parser.add_argument('-evalue',              required=False, default=0.0001,                 help='evalue cutoff, accepted format 0.001, 1e-10, 1e-30, default: 0.0001')
        arCOG_parser.add_argument('-f',                   required=False, action="store_true",            help='force overwrite')
        args = vars(parser.parse_args())
        arCOG.arCOG(args)

    elif sys.argv[1] == 'KEGG':
        from BioSAK import KEGG
        KEGG_parser = subparsers.add_parser('KEGG', description='Wrapper for KEGG annotation', usage=KEGG.KEGG_parser_usage)
        KEGG_parser.add_argument('-seq_in',                 required=False,                                 help='faa file')
        KEGG_parser.add_argument('-ko_in',                  required=False,                                 help='annotation results from BlastKOALA/GhostKOALA, normally with name user_ko.txt')
        KEGG_parser.add_argument('-x',                      required=False,                                 help='file extension')
        KEGG_parser.add_argument('-d',                      required=False, default=None,                   help='gene depth file/folder')
        KEGG_parser.add_argument('-pct_by_all',             required=False, action='store_true',            help='normalize by all query genes, rather than those with ko assignment')
        KEGG_parser.add_argument('-db_dir',                 required=True,                                  help='folder holds sequence, seq2ko and ko00001.keg files')
        KEGG_parser.add_argument('-diamond',                required=False, action='store_true',            help='run diamond (for big dataset), default is NCBI blastp')
        KEGG_parser.add_argument('-t',                      required=False, default=1,     type=int,        help='number of threads, default: 1')
        KEGG_parser.add_argument('-evalue',                 required=False, default=0.0001, type=float,     help='evalue cutoff, default: 0.0001')
        KEGG_parser.add_argument('-desc',                   required=False, action='store_true',            help='include KO functions in the final dataframe')
        args = vars(parser.parse_args())
        KEGG.Annotation_KEGG(args)

    elif sys.argv[1] == 'dbCAN':
        from BioSAK import dbCAN
        dbCAN_parser = subparsers.add_parser('dbCAN', description='Wrapper for running dbCAN', usage=dbCAN.dbCAN_parser_usage)
        dbCAN_parser.add_argument('-i',                     required=True,                                  help='path to input sequences (in multi-fasta format)')
        dbCAN_parser.add_argument('-x',                     required=False,                                 help='file extension')
        dbCAN_parser.add_argument('-m',                     required=False, default='P',                    help='The type of input sequences, "N/n" for "nucleotide", "P/p" for "protein"')
        dbCAN_parser.add_argument('-d',                     required=False, default=None,                   help='gene depth file/folder')
        dbCAN_parser.add_argument('-db_dir',                required=True,                                  help='db folder')
        dbCAN_parser.add_argument('-t',                     required=False, type=int, default=1,            help='number of threads')
        args = vars(parser.parse_args())
        dbCAN.dbCAN(args)

    elif sys.argv[1] == 'CheckM':
        from BioSAK import CheckM
        CheckM_parser = subparsers.add_parser('CheckM', description='Parse CheckM outputs', usage=CheckM.CheckM_usage)
        CheckM_parser.add_argument('-i',    required=True,                       help='CheckM produced quality file')
        CheckM_parser.add_argument('-o',    required=True,                       help='output quality file (reformatted)')
        CheckM_parser.add_argument('-g',    required=False,                      help='MAG folder')
        CheckM_parser.add_argument('-x',    required=False, default='fasta',     help='bin file extension')
        CheckM_parser.add_argument('-cpl',  required=False, type=float,          help='completeness cutoff (0-100)')
        CheckM_parser.add_argument('-ctm',  required=False, type=float,          help='contamination cutoff (0-100)')
        CheckM_parser.add_argument('-r',    required=False, action="store_true", help='recalculate contamination')
        args = vars(parser.parse_args())
        CheckM.CheckM(args)

    elif sys.argv[1] == 'split_folder':
        from BioSAK import split_folder
        split_folder_parser = subparsers.add_parser('split_folder', description='Split folder', usage=split_folder.split_folder_parser_usage)
        split_folder_parser.add_argument('-in',             required=True,                                  help='file folder')
        split_folder_parser.add_argument('-x',              required=True,                                  help='file extension')
        split_folder_parser.add_argument('-n',              required=False, type=int,                       help='number of subfolder')
        args = vars(parser.parse_args())
        split_folder.split_folder(args)

    elif sys.argv[1] == 'BestHit':
        from BioSAK import keep_best_hit
        BestHit_parser = subparsers.add_parser('BestHit', description='Keep blast hits with highest bit score', usage=keep_best_hit.BestHit_parser_usage)
        BestHit_parser.add_argument('-i',                   required=True,                                  help='input blast results (outfmt: 6)')
        BestHit_parser.add_argument('-o',                   required=True,                                  help='output file')
        args = vars(parser.parse_args())
        keep_best_hit.best_hit(args)

    elif sys.argv[1] == 'magabund':
        from BioSAK import magabund
        magabund_parser = subparsers.add_parser('magabund', description='Calculate MAG abundance', usage=magabund.magabund_usage)
        magabund_parser.add_argument('-s',       required=True,                        help='input sam file')
        magabund_parser.add_argument('-m',       required=True,                        help='MAG folder')
        magabund_parser.add_argument('-x',       required=False, default='fasta',      help='MAG file extension, default: fasta')
        magabund_parser.add_argument('-o',       required=True,                        help='output table')
        magabund_parser.add_argument('-a',       required=False, action='store_true',  help='based on aligned length, rather than read length')
        args = vars(parser.parse_args())
        magabund.magabund(args)

    elif sys.argv[1] == 'get_genome_NCBI':
        from BioSAK import get_genome_NCBI
        get_genome_NCBI_parser = subparsers.add_parser('get_genome_NCBI', description='Batch download NCBI genomes', usage=get_genome_NCBI.get_genome_NCBI_parser_usage)
        get_genome_NCBI_parser.add_argument('-i',   required=True,                       help='IDs of genomes to download')
        get_genome_NCBI_parser.add_argument('-o',   required=False, default=None,        help='output folder')
        get_genome_NCBI_parser.add_argument('-t',   required=False, default=1, type=int, help='number of threads')
        get_genome_NCBI_parser.add_argument('-f',   required=False, action="store_true", help='force overwrite existing genome directory')
        args = vars(parser.parse_args())
        get_genome_NCBI.download_GenBank_genome(args)

    elif sys.argv[1] == 'get_genome_GTDB':
        from BioSAK import get_genome_GTDB
        get_genome_GTDB_parser = subparsers.add_parser('get_genome_GTDB', description='Batch download GTDB genomes', usage=get_genome_GTDB.get_genome_GTDB_parser_usage)
        get_genome_GTDB_parser.add_argument('-i',           required=True,                          help='genome id')
        get_genome_GTDB_parser.add_argument('-o',           required=True,                          help='output folder')
        get_genome_GTDB_parser.add_argument('-fastani_dir', required=True,                          help='the "fastani" dir')
        get_genome_GTDB_parser.add_argument('-force',       required=False, action="store_true",    help='Force overwrite existing results')
        args = vars(parser.parse_args())
        get_genome_GTDB.get_genome_GTDB(args)

    elif sys.argv[1] == 'get_GTDB_taxon_gnm':
        from BioSAK import get_GTDB_taxon_gnm
        get_GTDB_taxon_gnm_parser = subparsers.add_parser('get_GTDB_taxon_gnm', description='get id of GTDB genomes from specified taxons', usage=get_GTDB_taxon_gnm.get_GTDB_taxon_gnm_parser_usage)
        get_GTDB_taxon_gnm_parser.add_argument('-p',           required=False, default='Genomes',          help='output prefix')
        get_GTDB_taxon_gnm_parser.add_argument('-meta',        required=True,                              help='GTDB reference genome metadata')
        get_GTDB_taxon_gnm_parser.add_argument('-path',        required=True,                              help='GTDB genome_paths.tsv')
        get_GTDB_taxon_gnm_parser.add_argument('-taxon',       required=True,                              help='interested taxons, one taxon per line')
        get_GTDB_taxon_gnm_parser.add_argument('-cpl',         required=False, default=None, type=float,   help='completeness cutoff (0-100), default: None')
        get_GTDB_taxon_gnm_parser.add_argument('-ctm',         required=False, default=None, type=float,   help='contamination cutoff, default: None')
        args = vars(parser.parse_args())
        get_GTDB_taxon_gnm.get_GTDB_taxon_gnm(args)

    elif sys.argv[1] == 'gbk2fna':
        from BioSAK import gbk2fna
        gbk2fna_parser = subparsers.add_parser('gbk2fna', description='gbk to fna (contig sequence)', usage=gbk2fna.gbk2fna_usage)
        gbk2fna_parser.add_argument('-i',  required=True,                       help='input gbk')
        gbk2fna_parser.add_argument('-ix', required=False, default='gbk',       help='input file extension, default: gbk')
        gbk2fna_parser.add_argument('-o',  required=True,                       help='output fna (contig sequences)')
        gbk2fna_parser.add_argument('-ox', required=False, default='fna',       help='output file extension, default: fna')
        gbk2fna_parser.add_argument('-t',  required=False, type=int, default=1, help='number of threads')
        args = vars(parser.parse_args())
        gbk2fna.gbk2fna(args)

    elif sys.argv[1] == 'gbk2faa':
        from BioSAK import gbk2faa
        gbk2faa_parser = subparsers.add_parser('gbk2faa', description='gbk to faa', usage=gbk2faa.gbk2faa_usage)
        gbk2faa_parser.add_argument('-i',   required=True,                          help='input gbk')
        gbk2faa_parser.add_argument('-ix',  required=False, default='gbk',          help='input file extension, default: gbk')
        gbk2faa_parser.add_argument('-o',   required=True,                          help='output faa')
        gbk2faa_parser.add_argument('-ox',  required=False, default='faa',          help='output file extension, default: faa')
        gbk2faa_parser.add_argument('-t',   required=False, type=int, default=1,    help='number of threads')
        args = vars(parser.parse_args())
        gbk2faa.gbk2faa(args)

    elif sys.argv[1] == 'gbk2ffn':
        from BioSAK import gbk2ffn
        gbk2faa_parser = subparsers.add_parser('gbk2ffn', description='gbk to ffn', usage=gbk2ffn.gbk2ffn_usage)
        gbk2faa_parser.add_argument('-i',  required=True,                       help='input gbk')
        gbk2faa_parser.add_argument('-ix', required=False, default='gbk',       help='input file extension, default: gbk')
        gbk2faa_parser.add_argument('-o',  required=True,                       help='output ffn')
        gbk2faa_parser.add_argument('-ox', required=False, default='ffn',       help='output file extension, default: ffn')
        gbk2faa_parser.add_argument('-t',  required=False, type=int, default=1, help='number of threads')
        args = vars(parser.parse_args())
        gbk2ffn.gbk2ffn(args)

    elif sys.argv[1] == 'ffn2faa':
        from BioSAK import format_converter
        ffn2faa_parser = subparsers.add_parser('ffn2faa', description='ffn to faa', usage=format_converter.sequence_manipulator_usage)
        ffn2faa_parser.add_argument('-ffn', required=True, help='input ffn file')
        args = vars(parser.parse_args())
        format_converter.ffn2faa(args)

    elif sys.argv[1] == 'get_rc':
        from BioSAK import format_converter
        get_rc_parser = subparsers.add_parser('get_rc', description='get reverse complement sequence', usage=format_converter.sequence_manipulator_usage)
        get_rc_parser.add_argument('-seq', required=True, help='input sequence(s)')
        args = vars(parser.parse_args())
        format_converter.get_rc(args)

    elif sys.argv[1] == 'slice_seq':
        from BioSAK import slice_seq
        slice_seq_parser = subparsers.add_parser('slice_seq', description='slice sequence', usage=slice_seq.slice_seq_usage)
        slice_seq_parser.add_argument('-in',    required=True,                        help='sequence file')
        slice_seq_parser.add_argument('-id',    required=True,                        help='sequence id')
        slice_seq_parser.add_argument('-range', required=True,                        help='sequence range, start-end (in bp). e.g. 200-4000')
        slice_seq_parser.add_argument('-rc',    required=False, action='store_true',  help='write out reverse complement sequence')
        slice_seq_parser.add_argument('-out',   required=True,                        help='output file')
        args = vars(parser.parse_args())
        slice_seq.slice_seq(args)

    elif sys.argv[1] == 'select_seq':
        from BioSAK import select_seq
        select_seq_parser = subparsers.add_parser('select_seq', description='select sequences', usage=select_seq.select_seq_usage)
        select_seq_parser.add_argument('-i',       required=True,                          help='fasta file')
        select_seq_parser.add_argument('-id',       required=True,                          help='sequence id,one id per line')
        select_seq_parser.add_argument('-o',       required=True,                          help='output file')
        select_seq_parser.add_argument('-exclude', required=False, action="store_true",    help='specify to extract sequences except those in -id')
        select_seq_parser.add_argument('-fq',      required=False, action="store_true",    help='in fastq format, default: fa')
        select_seq_parser.add_argument('-oneline', required=False, action="store_true",    help='put sequence in single line')
        args = vars(parser.parse_args())
        select_seq.select_seq(args)

    elif sys.argv[1] == 'get_Pfam_hmms':
        from BioSAK import get_Pfam_hmms
        get_Pfam_hmms_parser = subparsers.add_parser('get_Pfam_hmms', description='Get Pfam profiles by id', usage=get_Pfam_hmms.get_Pfam_hmms_usage)
        get_Pfam_hmms_parser.add_argument('-pfam',          required=True,                                  help='Pfam db file, normally with name Pfam-A.hmm')
        get_Pfam_hmms_parser.add_argument('-id',            required=True,                                  help='ids of profiles need to be extracted, one id per line')
        args = vars(parser.parse_args())
        get_Pfam_hmms.get_Pfam_hmms(args)

    elif sys.argv[1] == 'get_gene_depth':
        from BioSAK import get_gene_depth
        get_gene_depth_parser = subparsers.add_parser('get_gene_depth', description='Get gene depth by contig depth', usage=get_gene_depth.get_gene_depth_parser_usage)
        get_gene_depth_parser.add_argument('-gbk',          required=False, default=None,                   help='gbk file')
        get_gene_depth_parser.add_argument('-gff',          required=False, default=None,                   help='gff file')
        get_gene_depth_parser.add_argument('-ctg_depth',    required=True,                                  help='contig depth file')
        get_gene_depth_parser.add_argument('-id_column',    required=False, default=1, type=int,            help='contig id column, default is 1')
        get_gene_depth_parser.add_argument('-depth_column', required=False, default=2, type=int,            help='contig depth column, default is 2')
        get_gene_depth_parser.add_argument('-skip_header',  required=False, action='store_true',            help='skip the 1st line in contig depth file')
        args = vars(parser.parse_args())
        get_gene_depth.get_gene_depth(args)

    elif sys.argv[1] == 'rename_seq':
        from BioSAK import rename_seq
        rename_seq_parser = subparsers.add_parser('rename_seq', description='rename contigs in a file', usage=rename_seq.rename_seq_usage)
        rename_seq_parser.add_argument('-in',         required=True,                          help='input sequence file')
        rename_seq_parser.add_argument('-x',          required=False, default='fasta',        help='file extension, default: fasta')
        rename_seq_parser.add_argument('-sep_in',     required=False, default=None,           help='separator for input sequences')
        rename_seq_parser.add_argument('-sep_out',    required=False, default=None,           help='separator for output sequences, default: same as sep_in')
        rename_seq_parser.add_argument('-n',          required=False, default=None, type=int, help='the number of columns to keep')
        rename_seq_parser.add_argument('-prefix',     required=False, default=None,           help='add prefix to sequence')
        rename_seq_parser.add_argument('-oneline',    required=False, action="store_true",    help='put sequence in single line')
        rename_seq_parser.add_argument('-t',          required=False, type=int, default=1,    help='number of threads')
        args = vars(parser.parse_args())
        rename_seq.rename_seq(args)

    elif sys.argv[1] == 'SILVA_for_BLCA':
        from BioSAK import SILVA_for_BLCA
        SILVA_for_BLCA_parser = subparsers.add_parser('SILVA_for_BLCA', description='Prepare BLCA compatible SILVA SSU database', usage=SILVA_for_BLCA.SILVA_for_BLCA_usage)
        SILVA_for_BLCA_parser.add_argument('-i', required=True, help='SILVA SSU file, e.g. SILVA_138.2_SSURef_NR99_tax_silva.fasta')
        args = vars(parser.parse_args())
        SILVA_for_BLCA.SILVA_for_BLCA(args)

    elif sys.argv[1] == 'GTDB_for_BLCA':
        from BioSAK import GTDB_for_BLCA
        GTDB_for_BLCA_parser = subparsers.add_parser('GTDB_for_BLCA', description='Prepare BLCA compatible GTDB SSU database', usage=GTDB_for_BLCA.GTDB_for_BLCA_usage)
        GTDB_for_BLCA_parser.add_argument('-i', required=True, help='GTDB SSU file, e.g. ssu_all_r220.fna')
        args = vars(parser.parse_args())
        GTDB_for_BLCA.GTDB_for_BLCA(args)

    elif sys.argv[1] == 'Reads_simulator':
        from BioSAK import Reads_simulator
        Reads_simulator_parser = subparsers.add_parser('Reads_simulator', description='Simulate NGS reads', usage=Reads_simulator.Reads_simulator_usage)
        Reads_simulator_parser.add_argument('-p',     required=True,                            help='output prefix')
        Reads_simulator_parser.add_argument('-r',     required=True,                            help='reference genome')
        Reads_simulator_parser.add_argument('-n',     required=False, type=int,   default=None, help='number of read pairs to simulate')
        Reads_simulator_parser.add_argument('-d',     required=False, type=float, default=None, help='desired read depth (X)')
        Reads_simulator_parser.add_argument('-l',     required=True,  type=int,                 help='read length (bp)')
        Reads_simulator_parser.add_argument('-i',     required=True,  type=int,                 help='insert size (bp)')
        Reads_simulator_parser.add_argument('-split', action="store_true",                      help='Export forward and reverse reads to separate files')
        args = vars(parser.parse_args())
        Reads_simulator.Reads_simulator(args)

    elif sys.argv[1] == 'plot_sam_depth':
        from BioSAK import plot_sam_depth
        plot_sam_depth_parser = subparsers.add_parser('plot_sam_depth', description='plot sam depth', usage=plot_sam_depth.plot_sam_depth_usage)
        plot_sam_depth_parser.add_argument('-r',            required=True, type=str,                        help='reference sequence file')
        plot_sam_depth_parser.add_argument('-d',            required=True, type=str,                        help='depth file')
        plot_sam_depth_parser.add_argument('-i',            required=False, type=str, default=None,         help='id of sequence to plot')
        plot_sam_depth_parser.add_argument('-s',            required=False, type=int, default=None,         help='start position to plot')
        plot_sam_depth_parser.add_argument('-e',            required=False, type=int, default=None,         help='end position to plot')
        plot_sam_depth_parser.add_argument('-k',            required=False, type=int, default=100,          help='k-mer mean depth, default: 100')
        plot_sam_depth_parser.add_argument('-l',            required=False, type=str, default=None,         help='position to mark')
        plot_sam_depth_parser.add_argument('-x',            required=False, type=float, default=30,         help='plot width, default: 30')
        plot_sam_depth_parser.add_argument('-y',            required=False, type=float, default=10,         help='plot height, default: 10')
        args = vars(parser.parse_args())
        plot_sam_depth.plot_sam_depth(args)

    elif sys.argv[1] == 'rename_reads_for_Reago':
        from BioSAK import rename_reads_for_Reago
        rename_reads_for_Reago_parser = subparsers.add_parser('rename_reads_for_Reago', description='rename_reads_for_Reago', usage=rename_reads_for_Reago.rename_reads_for_Reago_usage)
        rename_reads_for_Reago_parser.add_argument('-in',  required=True, type=str, help='input fasta file')
        rename_reads_for_Reago_parser.add_argument('-out', required=True, type=str, help='renamed fasta file')
        rename_reads_for_Reago_parser.add_argument('-p',   required=True, type=str, help='prefix of renamed reads')
        rename_reads_for_Reago_parser.add_argument('-d',   required=True, type=int, help='chose from 1 (forward) or 2 (reverse)')
        args = vars(parser.parse_args())
        rename_reads_for_Reago.rename_reads_for_Reago(args)

    elif sys.argv[1] == 'MeanMappingDepth':
        from BioSAK import MeanMappingDepth
        MeanMappingDepth_parser = subparsers.add_parser('MeanMappingDepth', description='get mean mapping depth', usage=MeanMappingDepth.MeanMappingDepth_usage)
        MeanMappingDepth_parser.add_argument('-depth',  required=True,                          help='input depth file from "samtools depth" ')
        MeanMappingDepth_parser.add_argument('-T',      required=False, action="store_true",    help='get overall stats')
        args = vars(parser.parse_args())
        MeanMappingDepth.MeanMappingDepth(args)

    elif sys.argv[1] == 'js_cmds':
        from BioSAK import js_cmds
        js_cmds_parser = subparsers.add_parser('js_cmds', description='put commands into job scripts', usage=js_cmds.js_cmds_usage)
        js_cmds_parser.add_argument('-p',      required=True,                       help='js prefix')
        js_cmds_parser.add_argument('-cmd',    required=True,                       help='cmds file')
        js_cmds_parser.add_argument('-hd',     required=True,                       help='js header')
        js_cmds_parser.add_argument('-n',      required=True, type=int,             help='number of cmds per js')
        js_cmds_parser.add_argument('-auto',   required=False, action="store_true", help='automatically submit next js')
        js_cmds_parser.add_argument('-sbatch', required=False, action="store_true", help='use sbatch, instead of qsub')
        js_cmds_parser.add_argument('-js_hpc', required=False, default=None,        help='Full path to js folder on HPC')
        js_cmds_parser.add_argument('-force',  required=False, action="store_true", help='force overwrite existing results')
        args = vars(parser.parse_args())
        js_cmds.js_cmds(args)

    elif sys.argv[1] == 'reads2bam':
        from BioSAK import reads2bam
        reads2bam_parser = subparsers.add_parser('reads2bam', usage=reads2bam.reads2bam_usage)
        reads2bam_parser.add_argument('-p',         required=True,                          help='output prefix')
        reads2bam_parser.add_argument('-ref',       required=True,                          help='reference sequences')
        reads2bam_parser.add_argument('-index',     required=False, action="store_true",    help='index reference sequences')
        reads2bam_parser.add_argument('-r1',        required=False, default=None,           help='paired reads r1')
        reads2bam_parser.add_argument('-r2',        required=False, default=None,           help='paired reads r2')
        reads2bam_parser.add_argument('-up',        required=False, default=None,           help='unpaired reads')
        reads2bam_parser.add_argument('-fq',        required=False, action="store_true",    help='reads in fastq format')
        reads2bam_parser.add_argument('-local',     required=False, action="store_true",    help='perform local alignment')
        reads2bam_parser.add_argument('-no_unal',   required=False, action="store_true",    help='Suppress SAM records for reads that failed to align')
        reads2bam_parser.add_argument('-t',         required=False, type=int, default=1,    help='number of threads, default: 1')
        reads2bam_parser.add_argument('-tmp',       required=False, action="store_true",    help='keep temporary files')
        args = vars(parser.parse_args())
        reads2bam.reads2bam(args)

    elif sys.argv[1] == 'sam2bam':
        from BioSAK import sam2bam
        sam2bam_parser = subparsers.add_parser('sam2bam', usage=sam2bam.sam2bam_usage)
        sam2bam_parser.add_argument('-sam', required=True,                          help='sam file')
        sam2bam_parser.add_argument('-t',   required=False, type=int, default=1,    help='number of threads')
        args = vars(parser.parse_args())
        sam2bam.sam2bam(args)

    elif sys.argv[1] == 'BLCA_op_parser':
        from BioSAK import BLCA_op_parser
        BLCA_op_parser_parser = subparsers.add_parser('BLCA_op_parser', usage=BLCA_op_parser.BLCA_op_parser_usage)
        BLCA_op_parser_parser.add_argument('-in', required=True, help='BLCA output')
        args = vars(parser.parse_args())
        BLCA_op_parser.BLCA_op_parser(args)

    elif sys.argv[1] == 'VisGeneFlk':
        from BioSAK import VisGeneFlk
        VisGeneFlk_parser = subparsers.add_parser('VisGeneFlk', usage=VisGeneFlk.VisGeneFlk_usage)
        VisGeneFlk_parser.add_argument('-gene',    required=True,                          help='gene id')
        VisGeneFlk_parser.add_argument('-gbk',     required=True,                          help='gbk file')
        VisGeneFlk_parser.add_argument('-len',     required=True, type=int,                help='length (in bp) of flanking sequences to plot')
        VisGeneFlk_parser.add_argument('-scale',   required=False, type=int, default=200,  help='scale for plotting, default: 200bp per cm')
        VisGeneFlk_parser.add_argument('-fmt',     required=False, default='svg',          help='output format (svg or pdf), default: svg')
        VisGeneFlk_parser.add_argument('-no_label', required=False, action='store_true',    help='output format (svg or pdf), default: svg')
        args = vars(parser.parse_args())
        VisGeneFlk.VisGeneFlk(args)

    elif sys.argv[1] == 'usearch_uc':
        from BioSAK import usearch_uc
        usearch_uc_parser = subparsers.add_parser('usearch_uc', usage=usearch_uc.usearch_uc_usage)
        usearch_uc_parser.add_argument('-uc', required=True,                        help='uc file from Usearch')
        usearch_uc_parser.add_argument('-n',  required=False, type=int, default=1,  help='minimum number of sequence in a cluster, default: 1')
        usearch_uc_parser.add_argument('-o',  required=True,                        help='output file')
        args = vars(parser.parse_args())
        usearch_uc.usearch_uc(args)

    elif sys.argv[1] == 'top_16S_hits':
        from BioSAK import top_16S_hits
        top_16S_hits_parser = subparsers.add_parser('top_16S_hits', usage=top_16S_hits.top_16S_hits_usage)
        top_16S_hits_parser.add_argument('-p',           required=True,                           help='output prefix')
        top_16S_hits_parser.add_argument('-q',           required=True,                           help='query sequence file')
        top_16S_hits_parser.add_argument('-r',           required=True,                           help='SILVA or GTDB SSU sequence file')
        top_16S_hits_parser.add_argument('-b',           required=False, default=None,            help='blast results between query and reference sequences from previous analysis(if you have)')
        top_16S_hits_parser.add_argument('-evalue',      required=False, default='1e-20',         help='evalue cutoff, default: 1e-20')
        top_16S_hits_parser.add_argument('-top',         required=False, type=int, default=1,     help='Number of top hits to report, default: 1')
        top_16S_hits_parser.add_argument('-t',           required=False, type=int, default=1,     help='number of threads')
        args = vars(parser.parse_args())
        top_16S_hits.top_16S_hits(args)

    elif sys.argv[1] == 'Plot_MAG':
        from BioSAK import plot_mag
        Plot_MAG_parser = subparsers.add_parser('Plot_MAG', usage=plot_mag.Plot_MAG_parser_usage)
        Plot_MAG_parser.add_argument('-i',   required=True,                         help='MAG folder')
        Plot_MAG_parser.add_argument('-x',   required=True,                         help='file extension')
        Plot_MAG_parser.add_argument('-d',   required=True,                         help='contig depth')
        Plot_MAG_parser.add_argument('-sep', required=False, action='store_true',   help='get plot for individual MAGs')
        args = vars(parser.parse_args())
        plot_mag.Plot_MAG(args)

    elif sys.argv[1] == 'get_gnm_size':
        from BioSAK import get_gnm_size
        get_gnm_size_parser = subparsers.add_parser('get_gnm_size', usage=get_gnm_size.get_gnm_size_parser_usage)
        get_gnm_size_parser.add_argument('-i',      required=True,                          help='MAG file/folder')
        get_gnm_size_parser.add_argument('-x',      required=False,                         help='file extension')
        get_gnm_size_parser.add_argument('-total',  required=False, action='store_true',    help='get total size')
        args = vars(parser.parse_args())
        get_gnm_size.get_gnm_size(args)

    elif sys.argv[1] == 'fq2fa':
        from BioSAK import fq2fa
        fq2fa_parser = subparsers.add_parser('fq2fa', usage=fq2fa.fq2fa_usage)
        fq2fa_parser.add_argument('-i', required=True, help='input fastq')
        fq2fa_parser.add_argument('-o', required=True, help='output fasta')
        args = vars(parser.parse_args())
        fq2fa.fq2fa(args)

    elif sys.argv[1] == 'mean_MAG_cov':
        from BioSAK import mean_MAG_cov
        mean_MAG_cov_parser = subparsers.add_parser('mean_MAG_cov', usage=mean_MAG_cov.mean_MAG_cov_usage)
        mean_MAG_cov_parser.add_argument('-d', required=True, help='MetaBAT produced depth file')
        mean_MAG_cov_parser.add_argument('-b', required=True, help='bin folder')
        mean_MAG_cov_parser.add_argument('-x', required=True, help='file extension')
        args = vars(parser.parse_args())
        mean_MAG_cov.mean_MAG_cov(args)

    elif sys.argv[1] == 'exe_cmds':
        from BioSAK import exe_cmds
        exe_cmds_parser = subparsers.add_parser('exe_cmds', usage=exe_cmds.exe_cmds_usage)
        exe_cmds_parser.add_argument('-c', required=True,                       help='cmds file')
        exe_cmds_parser.add_argument('-t', required=False, type=int, default=1, help='number of threads')
        args = vars(parser.parse_args())
        exe_cmds.exe_cmds(args)

    elif sys.argv[1] == 'split_fasta':
        from BioSAK import split_fasta
        split_fasta_parser = subparsers.add_parser('split_fasta', usage=split_fasta.split_fasta_usage)
        split_fasta_parser.add_argument('-i',  required=True,                          help='input fasta file')
        split_fasta_parser.add_argument('-o',  required=True,                          help='output dir')
        split_fasta_parser.add_argument('-ns', required=False, default=None, type=int, help='number of sequences per file')
        split_fasta_parser.add_argument('-nf', required=False, default=None, type=int, help='number of files to be generated')
        args = vars(parser.parse_args())
        split_fasta.split_fasta(args)

    elif sys.argv[1] == 'split_sam':
        from BioSAK import split_sam
        split_sam_parser = subparsers.add_parser('split_sam', usage=split_sam.split_sam_usage)
        split_sam_parser.add_argument('-p', required=True,                          help='output prefix')
        split_sam_parser.add_argument('-i', required=True,                          help='input SAM/BAM file')
        split_sam_parser.add_argument('-r', required=True,                          help='reference id')
        split_sam_parser.add_argument('-t', required=False, type=int, default=1,    help='number of threads')
        args = vars(parser.parse_args())
        split_sam.split_sam(args)

    elif sys.argv[1] == 'fa2id':
        from BioSAK import fa2id
        fa2id_parser = subparsers.add_parser('fa2id', usage=fa2id.fa2id_usage)
        fa2id_parser.add_argument('-i',  required=True,                         help='input fasta/fastq file')
        fa2id_parser.add_argument('-o',  required=True,                         help='output txt')
        fa2id_parser.add_argument('-d',  required=False, action="store_true",   help='additionally export description, default: false')
        fa2id_parser.add_argument('-fq', required=False, action="store_true",   help='in fastq format, default: fasta')
        args = vars(parser.parse_args())
        fa2id.fa2id(args)

    elif sys.argv[1] == 'sampling_GTDB_gnms':
        from BioSAK import sampling_GTDB_gnms
        sampling_GTDB_gnms_parser = subparsers.add_parser('sampling_GTDB_gnms', usage=sampling_GTDB_gnms.sampling_GTDB_gnms_usage)
        sampling_GTDB_gnms_parser.add_argument('-o',           required=True,                              help='output table')
        sampling_GTDB_gnms_parser.add_argument('-meta',        required=True,                              help='GTDB reference genome metadata')
        sampling_GTDB_gnms_parser.add_argument('-taxon',       required=True,                              help='interested taxon')
        sampling_GTDB_gnms_parser.add_argument('-r',           required=True,                              help='sampling at rank, select from p, c, o, f, g and s')
        sampling_GTDB_gnms_parser.add_argument('-n',           required=False, default=1, type=int,        help='numer of genome to retain per taxon')
        sampling_GTDB_gnms_parser.add_argument('-cpl',         required=False, default=None, type=float,   help='completeness cutoff (0-100), default: None')
        sampling_GTDB_gnms_parser.add_argument('-ctm',         required=False, default=None, type=float,   help='contamination cutoff, default: None')
        sampling_GTDB_gnms_parser.add_argument('-ts',          required=False, action='store_true',        help='only consider type strain')
        sampling_GTDB_gnms_parser.add_argument('-rs',          required=False, action='store_true',        help='only consider representative species')
        args = vars(parser.parse_args())
        sampling_GTDB_gnms.sampling_GTDB_gnms(args)

    elif sys.argv[1] == 'subset_GTDB_meta':
        from BioSAK import subset_GTDB_meta
        subset_GTDB_meta_parser = subparsers.add_parser('subset_GTDB_meta', usage=subset_GTDB_meta.subset_GTDB_meta_usage)
        subset_GTDB_meta_parser.add_argument('-meta',    required=True, help='GTDB reference genome metadata')
        subset_GTDB_meta_parser.add_argument('-id',      required=True, help='id of genomes')
        subset_GTDB_meta_parser.add_argument('-out',     required=True, help='output file')
        args = vars(parser.parse_args())
        subset_GTDB_meta.subset_GTDB_meta(args)

    elif sys.argv[1] == 'get_MAG_reads_long':
        from BioSAK import get_MAG_reads_long
        get_MAG_reads_long_parser = subparsers.add_parser('get_MAG_reads_long', usage=get_MAG_reads_long.get_MAG_reads_long_usage)
        get_MAG_reads_long_parser.add_argument('-r',    required=True,                             help='reads file')
        get_MAG_reads_long_parser.add_argument('-s',    required=True,                             help='sam file')
        get_MAG_reads_long_parser.add_argument('-m',    required=True,                             help='MAG file/folder')
        get_MAG_reads_long_parser.add_argument('-x',    required=False, default='fasta',           help='MAG extension, default: fasta')
        get_MAG_reads_long_parser.add_argument('-l',    required=False, type=int, default=5000,    help='minimal read length (in bp), default: 5000')
        get_MAG_reads_long_parser.add_argument('-o',    required=True,                             help='output folder')
        args = vars(parser.parse_args())
        get_MAG_reads_long.get_MAG_reads_long(args)

    elif sys.argv[1] == 'bam2reads':
        from BioSAK import bam2reads
        bam2reads_parser = subparsers.add_parser('bam2reads', usage=bam2reads.bam2reads_usage)
        bam2reads_parser.add_argument('-b',       required=True,                       help='Sorted Bam file')
        bam2reads_parser.add_argument('-r',       required=True,                       help='Interested region')
        bam2reads_parser.add_argument('-s',       required=False, default=None,        help='Read sequence file')
        bam2reads_parser.add_argument('-o',       required=True,                       help='Output folder')
        bam2reads_parser.add_argument('-force',   required=False, action="store_true", help='Force overwriting')
        args = vars(parser.parse_args())
        bam2reads.bam2reads(args)

    elif sys.argv[1] == 'merge_seq':
        from BioSAK import merge_seq
        merge_seq_parser = subparsers.add_parser('merge_seq', usage=merge_seq.merge_seq_usage)
        merge_seq_parser.add_argument('-1',       required=True,                          help='input file 1')
        merge_seq_parser.add_argument('-2',       required=True,                          help='input file 2')
        merge_seq_parser.add_argument('-o',       required=True,                          help='output sequence file')
        merge_seq_parser.add_argument('-fq',      required=False, action="store_true",    help='in fastq format, default: fasta')
        merge_seq_parser.add_argument('-sl',      required=False, action="store_true",    help='write out sequence in single line format')
        args = vars(parser.parse_args())
        merge_seq.merge_seq(args)

    elif sys.argv[1] == 'cross_link_seqs':
        from BioSAK import cross_link_seqs
        cross_link_seqs_parser = subparsers.add_parser('cross_link_seqs', usage=cross_link_seqs.cross_link_seqs_usage)
        cross_link_seqs_parser.add_argument('-p', required=True,                 help='output prefix')
        cross_link_seqs_parser.add_argument('-1', required=True,                 help='sequence 1, in fasta format')
        cross_link_seqs_parser.add_argument('-2', required=True,                 help='sequence 2, in fasta format')
        cross_link_seqs_parser.add_argument('-i', required=True, type=float,     help='identity cutoff, 0-100')
        cross_link_seqs_parser.add_argument('-l', required=True, type=int,       help='alignment length cutoff, in bp')
        cross_link_seqs_parser.add_argument('-f', required=False, default='PDF', help='plot format, choose from PDF, SVG, EPS and PNG, default: PDF')
        args = vars(parser.parse_args())
        cross_link_seqs.cross_link_seqs(args)

    elif sys.argv[1] == 'RunGraphMB':
        from BioSAK import RunGraphMB
        RunGraphMB_parser = subparsers.add_parser('RunGraphMB', usage=RunGraphMB.RunGraphMB_usage)
        RunGraphMB_parser.add_argument('-gfa',  required=True, help='gfa file')
        RunGraphMB_parser.add_argument('-o',    required=True, help='output folder (i.e., input folder to GraphMB)')
        args = vars(parser.parse_args())
        RunGraphMB.RunGraphMB(args)

    elif sys.argv[1] == 'gfa2fa':
        from BioSAK import format_converter
        gfa2fa_parser = subparsers.add_parser('gfa2fa', description='gfa to fasta', usage=format_converter.sequence_manipulator_usage)
        gfa2fa_parser.add_argument('-gfa', required=True, help='input gfa file')
        gfa2fa_parser.add_argument('-o',   required=True, help='output fasta file')
        args = vars(parser.parse_args())
        format_converter.gfa2fa(args)

    elif sys.argv[1] == 'cat_fa':
        from BioSAK import cat_fa
        cat_fa_parser = subparsers.add_parser('cat_fa', description='combine sequence files', usage=cat_fa.cat_fa_usage)
        cat_fa_parser.add_argument('-i', required=True,                     help='sequence folder')
        cat_fa_parser.add_argument('-x', required=False, default='fasta',   help='file extension, default: fasta')
        cat_fa_parser.add_argument('-s', required=False, default='__',      help='separator, default: __')
        cat_fa_parser.add_argument('-o', required=True,                     help='combined output file')
        args = vars(parser.parse_args())
        cat_fa.cat_fa(args)

    elif sys.argv[1] == 'SubsampleLongReads':
        from BioSAK import SubsampleLongReads
        SubsampleLongReads_parser = subparsers.add_parser('SubsampleLongReads', description='Subsample Long Reads', usage=SubsampleLongReads.SubsampleLongReads_usage)
        SubsampleLongReads_parser.add_argument('-i',        required=True,                          help='input sequence file')
        SubsampleLongReads_parser.add_argument('-s',        required=True,                          help='separate subsample rates (1-100) with comma, e.g. 1,5,10')
        SubsampleLongReads_parser.add_argument('-o',        required=True,                          help='output directory')
        SubsampleLongReads_parser.add_argument('-fq',       required=False, action="store_true",    help='in fastq format, default: fa')
        SubsampleLongReads_parser.add_argument('-oneline',  required=False, action="store_true",    help='put sequence in single line')
        args = vars(parser.parse_args())
        SubsampleLongReads.SubsampleLongReads(args)

    elif sys.argv[1] == 'metaBiosample':
        from BioSAK import MetaBiosample
        MetaBiosample_parser = subparsers.add_parser('MetaBiosample', usage=MetaBiosample.MetaBiosample_usage)
        MetaBiosample_parser.add_argument('-i',     required=True,                          help='biosample id file, one id per line')
        MetaBiosample_parser.add_argument('-a',     required=True,                          help='attributes to extract')
        MetaBiosample_parser.add_argument('-o',     required=True,                          help='output folder')
        MetaBiosample_parser.add_argument('-t',     required=False, type=int, default=1,    help='number of threads, default: 1')
        MetaBiosample_parser.add_argument('-f',     required=False, action="store_true",    help='Force overwrite existing results')
        MetaBiosample_parser.add_argument('-exe',   required=False, action="store_true",    help='execute cmds')
        args = vars(parser.parse_args())
        MetaBiosample.MetaBiosample(args)

    elif sys.argv[1] == 'metabat2concoct':
        from BioSAK import metabat2concoct
        metabat2concoct_parser = subparsers.add_parser('metabat2concoct', usage=metabat2concoct.metabat2concoct_usage)
        metabat2concoct_parser.add_argument('-i', required=True, help='metabat depth')
        metabat2concoct_parser.add_argument('-o', required=True, help='concoct depth')
        args = vars(parser.parse_args())
        metabat2concoct.metabat2concoct(args)

    elif sys.argv[1] == 'metabat2maxbin':
        from BioSAK import metabat2maxbin
        metabat2maxbin_parser = subparsers.add_parser('metabat2maxbin', usage=metabat2maxbin.metabat2maxbin_usage)
        metabat2maxbin_parser.add_argument('-p', required=True, help='output prefix for maxbin depth file')
        metabat2maxbin_parser.add_argument('-i', required=True, help='metabat depth')
        args = vars(parser.parse_args())
        metabat2maxbin.metabat2maxbin(args)

    elif sys.argv[1] == 'prokka':
        from BioSAK import prokka
        prokka_parser = subparsers.add_parser('prokka', usage=prokka.prokka_usage)
        prokka_parser.add_argument('-i',          required=True,                          help='genome folder')
        prokka_parser.add_argument('-x',          required=True, default='fna',           help='file extension, deafult: fna')
        prokka_parser.add_argument('-d',          required=True,                          help='genome domain, Bacteria or Archaea')
        prokka_parser.add_argument('-m',          required=False, action="store_true",    help='annotate MAG')
        prokka_parser.add_argument('-e',          required=False, action="store_true",    help='execute commands')
        prokka_parser.add_argument('-t',          required=False, type=int, default=1,    help='number of threads')
        args = vars(parser.parse_args())
        prokka.prokka(args)

    elif sys.argv[1] == 'prefix_file':
        from BioSAK import prefix_file
        prefix_file_parser = subparsers.add_parser('prefix_file', usage=prefix_file.prefix_file_usage)
        prefix_file_parser.add_argument('-p',   required=True,                          help='add prefix to sequence')
        prefix_file_parser.add_argument('-i',   required=True,                          help='input sequence file')
        prefix_file_parser.add_argument('-x',   required=True,                          help='file extension, default: fasta')
        prefix_file_parser.add_argument('-o',   required=True,                          help='the number of columns to keep')
        prefix_file_parser.add_argument('-f',   required=False, action="store_true",    help='force overwrite previous results')
        args = vars(parser.parse_args())
        prefix_file.prefix_file(args)

    elif sys.argv[1] == 'submitHPC':
        from BioSAK import submitHPC
        submitHPC_parser = subparsers.add_parser('submitHPC', usage=submitHPC.submitHPC_usage)
        submitHPC_parser.add_argument('-p', required=True,                          help='js prefix')
        submitHPC_parser.add_argument('-c', required=True,                          help='commands txt')
        submitHPC_parser.add_argument('-t', required=False, type=int, default=1,    help='number of threads')
        args = vars(parser.parse_args())
        submitHPC.submitHPC(args)

    elif sys.argv[1] == 'KeepRemovingTmp':
        from BioSAK import KeepRemovingTmp
        KeepRemovingTmp_parser = subparsers.add_parser('KeepRemovingTmp', usage=KeepRemovingTmp.KeepRemovingTmp_usage)
        KeepRemovingTmp_parser.add_argument('-d', required=True, help='tmp dir')
        KeepRemovingTmp_parser.add_argument('-l', required=True, help='time length, e.g., 10s, 30m, 6h or 5d')
        args = vars(parser.parse_args())
        KeepRemovingTmp.KeepRemovingTmp(args)

    elif sys.argv[1] == 'parse_mmseqs_tsv':
        from BioSAK import parse_mmseqs_tsv
        parse_mmseqs_tsv_parser = subparsers.add_parser('parse_mmseqs_tsv', usage=parse_mmseqs_tsv.parse_mmseqs_tsv_usage)
        parse_mmseqs_tsv_parser.add_argument('-i', required=True, help='tsv file produced by "mmseqs createtsv"')
        parse_mmseqs_tsv_parser.add_argument('-o', required=True, help='output table')
        args = vars(parser.parse_args())
        parse_mmseqs_tsv.parse_mmseqs_tsv(args)

    elif sys.argv[1] == 'hpc3':
        from BioSAK import hpc3
        hpc3_parser = subparsers.add_parser('hpc3', usage=hpc3.hpc3_usage)
        hpc3_parser.add_argument('-c',        required=True,                          help='command to submit')
        hpc3_parser.add_argument('-n',        required=True,                          help='job name')
        hpc3_parser.add_argument('-m',        required=False, default=None,           help='email address')
        hpc3_parser.add_argument('-wt',       required=False, default='23:59:59',     help='walltime, default: 23:59:59')
        hpc3_parser.add_argument('-node',     required=False, type=int, default=1,    help='number of node, default: 1')
        hpc3_parser.add_argument('-t',        required=False, type=int, default=12,   help='number of core, default: 12')
        hpc3_parser.add_argument('-tpc',      required=False, type=int, default=1,    help='number of core per command, default: 1')
        hpc3_parser.add_argument('-a',        required=False, default='boqianpy',     help='-A, boqianpy or oces, default: boqianpy')
        hpc3_parser.add_argument('-q',        required=True,                          help='queue, select from cpu, cpu-share, himem and himem-share')
        hpc3_parser.add_argument('-conda',    required=False, default=None,           help='conda environment')
        hpc3_parser.add_argument('-srun',     required=False, action='store_true',    help='use srun')
        args = vars(parser.parse_args())
        hpc3.hpc3(args)

    elif sys.argv[1] == 'enrich':
        from BioSAK import enrich
        enrich_parser = subparsers.add_parser('enrich', usage=enrich.enrich_usage)
        enrich_parser.add_argument('-p',    required=False, default='',             help='prefix of output files')
        enrich_parser.add_argument('-i',    required=True,                          help='annotation files')
        enrich_parser.add_argument('-x',    required=True,                          help='file extension')
        enrich_parser.add_argument('-g',    required=True,                          help='grouping file')
        enrich_parser.add_argument('-o',    required=True,                          help='output directory')
        enrich_parser.add_argument('-diff', required=False, default=2, type=float,  help='minimum fold difference, default is 2')
        enrich_parser.add_argument('-bc',   required=False, action="store_true",    help='perform Bonferroni correction')
        enrich_parser.add_argument('-f',    required=False, action="store_true",    help='force overwrite')
        args = vars(parser.parse_args())
        enrich.enrich(args)

    elif sys.argv[1] == 'metaAssembly':
        from BioSAK import metaAssembly
        metaAssembly_parser = subparsers.add_parser('metaAssembly', usage=metaAssembly.metaAssembly_usage)
        metaAssembly_parser.add_argument('-i', required=True,                         help='file contains assembly ids')
        metaAssembly_parser.add_argument('-o', required=True,                         help='output directory')
        metaAssembly_parser.add_argument('-f', required=False, action="store_true",   help='force overwrite')
        metaAssembly_parser.add_argument('-t', required=False, type=int, default=1,   help='number of cores, default: 1')
        args = vars(parser.parse_args())
        metaAssembly.metaAssembly(args)

    elif sys.argv[1] == 'js_hpc3':
        from BioSAK import js_hpc3
        js_hpc3_parser = subparsers.add_parser('js_hpc3', usage=js_hpc3.js_hpc3_usage)
        js_hpc3_parser.add_argument('-p',       required=True,                          help='js prefix')
        js_hpc3_parser.add_argument('-c',       required=True,                          help='cmds file')
        js_hpc3_parser.add_argument('-hd',      required=True,                          help='js header')
        js_hpc3_parser.add_argument('-n',       required=True,  type=int,               help='number of cmds per job script')
        js_hpc3_parser.add_argument('-t',       required=False, type=int, default=1,    help='number of threads specified in the commands')
        js_hpc3_parser.add_argument('-f',       required=False, action="store_true",    help='force overwrite existing results')
        args = vars(parser.parse_args())
        js_hpc3.js_hpc3(args)

    elif sys.argv[1] == 'koala':
        from BioSAK import koala
        koala_parser = subparsers.add_parser('koala', usage=koala.koala_usage)
        koala_parser.add_argument('-i', required=True,                          help='user_ko.txt from BlastKOALA or GhostKOALA')
        koala_parser.add_argument('-o', required=True,                          help='output directory')
        koala_parser.add_argument('-f', required=False, action="store_true",    help='force overwrite')
        args = vars(parser.parse_args())
        koala.koala(args)

    elif sys.argv[1] == 'subset_df':
        from BioSAK import subset_df
        subset_df_parser = subparsers.add_parser('subset_df', usage=subset_df.subset_df_usage)
        subset_df_parser.add_argument('-i',         required=True,                          help='input file')
        subset_df_parser.add_argument('-o',         required=True,                          help='output file')
        subset_df_parser.add_argument('-c',         required=False, default=None,           help='header of columns to keep')
        subset_df_parser.add_argument('-r',         required=False, default=None,           help='header of rows to keep')
        subset_df_parser.add_argument('-s',         required=False, default='tab',          help='column separator, choose from tab and comma, default: tab')
        subset_df_parser.add_argument('-b',         required=False, action='store_true',    help='write out dataframe in 0/1 format')
        subset_df_parser.add_argument('-e',         required=False, action='store_true',    help='subset df by excluding the specified rows/columns')
        subset_df_parser.add_argument('-m',         required=False, action='store_true',    help='convert 0 to -1')
        subset_df_parser.add_argument('-skip1row',  required=False, action='store_true',    help='skip the 1st row of the -c/-r file')
        args = vars(parser.parse_args())
        subset_df.subset_df(args)

    elif sys.argv[1] == 'add_desc':
        from BioSAK import add_desc
        add_desc_parser = subparsers.add_parser('add_desc', usage=add_desc.add_desc_usage)
        add_desc_parser.add_argument('-i', required=True, help='input file ')
        add_desc_parser.add_argument('-o', required=True, help='output file')
        add_desc_parser.add_argument('-d', required=True, help='database file')
        args = vars(parser.parse_args())
        add_desc.add_desc(args)

    elif sys.argv[1] == 'merge_df':
        from BioSAK import merge_df
        merge_df_parser = subparsers.add_parser('merge_df', usage=merge_df.merge_df_usage)
        merge_df_parser.add_argument('-1',     required=True,                          help='the first input dataframe')
        merge_df_parser.add_argument('-2',     required=True,                          help='the second input dataframe')
        merge_df_parser.add_argument('-o',     required=True,                          help='output file')
        merge_df_parser.add_argument('-s',     required=False, default='tab',          help='column separator, choose from tab and comma, default: tab')
        args = vars(parser.parse_args())
        merge_df.merge_df(args)

    elif sys.argv[1] == 'gapseq':
        from BioSAK import gapseq
        gapseq_parser = subparsers.add_parser('gapseq', usage=gapseq.gapseq_usage)
        gapseq_parser.add_argument('-i',       required=True,                        help='folder holds the *Pathways.tbl files')
        gapseq_parser.add_argument('-o',       required=True,                        help='output file')
        gapseq_parser.add_argument('-name',    required=False, action="store_true",  help='include pathway name in the output dataframe')
        args = vars(parser.parse_args())
        gapseq.gapseq(args)

    elif sys.argv[1] == 'transpose':
        from BioSAK import transpose
        transpose_parser = subparsers.add_parser('transpose', usage=transpose.transpose_usage)
        transpose_parser.add_argument('-i', required=True,      help='input file')
        transpose_parser.add_argument('-o', required=True,      help='output file')
        args = vars(parser.parse_args())
        transpose.transpose(args)

    elif sys.argv[1] == 'gc':
        from BioSAK import gc
        gc_parser = subparsers.add_parser('gc', usage=gc.gc_usage)
        gc_parser.add_argument('-i',        required=True,     help='sequence file/folder')
        gc_parser.add_argument('-x',        required=False,    help='file extension')
        args = vars(parser.parse_args())
        gc.gc(args)

    elif sys.argv[1] == 'wilcox':
        from BioSAK import wilcox
        wilcox_parser = subparsers.add_parser('wilcox', usage=wilcox.wilcox_usage)
        wilcox_parser.add_argument('-1', required=True, help='treatment 1')
        wilcox_parser.add_argument('-2', required=True, help='treatment 2')
        args = vars(parser.parse_args())
        wilcox.wilcox(args)

    elif sys.argv[1] == 'mannwhitneyu':
        from BioSAK import mann_whitney_u
        mannwhitneyu_parser = subparsers.add_parser('mannwhitneyu', usage=mann_whitney_u.mannwhitneyu_usage)
        mannwhitneyu_parser.add_argument('-i', required=True, help='input file')
        args = vars(parser.parse_args())
        mann_whitney_u.mann_whitney_u(args)

    elif sys.argv[1] == 'compare_sets':
        from BioSAK import compare_sets
        compare_sets_parser = subparsers.add_parser('compare_sets', usage=compare_sets.compare_sets_usage)
        compare_sets_parser.add_argument('-1', required=True, help='file 1')
        compare_sets_parser.add_argument('-2', required=True, help='file 2')
        args = vars(parser.parse_args())
        compare_sets.compare_sets(args)

    elif sys.argv[1] == 'ribbon':
        from BioSAK import ribbon
        ribbon_parser = subparsers.add_parser('ribbon', usage=ribbon.ribbon_usage)
        ribbon_parser.add_argument('-o',                    required=True,                                  help='output directory')
        ribbon_parser.add_argument('-fa',                   required=True,                                  help='fa file directory')
        ribbon_parser.add_argument('-fax',                  required=False, default='fa',                   help='fa file extension, default: fa')
        ribbon_parser.add_argument('-gff',                  required=False,                                 help='gff file directory')
        ribbon_parser.add_argument('-gffx',                 required=False, default='gff',                  help='gff file extension, default: gff')
        ribbon_parser.add_argument('-gbk',                  required=False,                                 help='gbk file directory')
        ribbon_parser.add_argument('-gbkx',                 required=False, default='gbk',                  help='gbk file extension, default: gbk')
        ribbon_parser.add_argument('-pep',                  required=False,                                 help='pep file directory')
        ribbon_parser.add_argument('-pepx',                 required=False, default='pep',                  help='pep file extension, default: pep')
        ribbon_parser.add_argument('-chrom',                required=False,                                 help='chrom file directory')
        ribbon_parser.add_argument('-chromx',               required=False, default='chrom',                help='chrom file extension, default: chrom')
        ribbon_parser.add_argument('-so',                   required=False, default=None,                   help='species order in the ribbon diagram')
        ribbon_parser.add_argument('-co',                   required=False, default=None,                   help='chromosome order in the ribbon diagram')
        ribbon_parser.add_argument('-m',                    required=False, type=int, default=10,           help='minscafsize, default: 10')
        ribbon_parser.add_argument('-t',                    required=False, type=int, default=1,            help='number of core, default: 1')
        ribbon_parser.add_argument('-f',                    required=False, action="store_true",            help='force overwrite')
        ribbon_parser.add_argument('-plot_all',             required=False, action="store_true",            help='plot_all')
        ribbon_parser.add_argument('-plot_lgs',             required=False, action="store_true",            help='plot_LGs')
        ribbon_parser.add_argument('-odp',                  required=False, default='odp',                  help='executable file odp, default: odp')
        ribbon_parser.add_argument('-odp_rbh_to_ribbon',    required=False, default='odp_rbh_to_ribbon',    help='executable file odp_rbh_to_ribbon, default: odp_rbh_to_ribbon')
        args = vars(parser.parse_args())
        ribbon.ribbon(args)

    elif sys.argv[1] == 'count_num':
        from BioSAK import count_num
        count_num_parser = subparsers.add_parser('count_num', usage=count_num.count_num_usage)
        count_num_parser.add_argument('-i', required=True, help='input file')
        count_num_parser.add_argument('-c', required=False, default=1, help='column, default: 1 (the first column)')
        args = vars(parser.parse_args())
        count_num.count_num(args)

    elif sys.argv[1] == 'fastaai':
        from BioSAK import fastaai
        fastaai_parser = subparsers.add_parser('fastaai', usage=fastaai.fastaai_usage)
        fastaai_parser.add_argument('-i', required=True,                          help='faa files')
        fastaai_parser.add_argument('-x', required=False, default='faa',          help='file extension, default: faa')
        fastaai_parser.add_argument('-o', required=True,                          help='output directory')
        fastaai_parser.add_argument('-t', required=False, default=1, type=int,    help='number of threads, default: 1')
        fastaai_parser.add_argument('-f', required=False, action="store_true",    help='force overwrite')
        args = vars(parser.parse_args())
        fastaai.fastaai(args)

    elif sys.argv[1] == 'statsTaxa':
        from BioSAK import statsTaxa
        statsTaxa_parser = subparsers.add_parser('statsTaxa', usage=statsTaxa.statsTaxa_usage)
        statsTaxa_parser.add_argument('-i', required=True, help='input txt')
        statsTaxa_parser.add_argument('-o', required=True, help='output txt')
        args = vars(parser.parse_args())
        statsTaxa.statsTaxa(args)

    elif sys.argv[1] == 'sankey':
        from BioSAK import sankey
        sankey_parser = subparsers.add_parser('sankey', usage=sankey.sankey_usage)
        sankey_parser.add_argument('-i', required=True,                         help='input datamatrix')
        sankey_parser.add_argument('-p', required=True,                         help='output prefix')
        sankey_parser.add_argument('-m', required=False, type=int, default=1,   help='Minimal value to plot, default is 1')
        sankey_parser.add_argument('-x', required=False, type=int,              help='plot width')
        sankey_parser.add_argument('-y', required=False, type=int,              help='plot height')
        args = vars(parser.parse_args())
        sankey.sankey(args)

    elif sys.argv[1] == 'srun':
        from BioSAK import srun
        srun_parser = subparsers.add_parser('srun', usage=srun.srun_usage)
        srun_parser.add_argument('-c', required=True, help='command to run')
        args = vars(parser.parse_args())
        srun.srun(args)

    elif sys.argv[1] == 'stats_ko':
        from BioSAK import stats_ko
        stats_ko_parser = subparsers.add_parser('stats_ko', usage=stats_ko.stats_ko_usage)
        stats_ko_parser.add_argument('-ko',         required=True,                          help='ko.txt')
        stats_ko_parser.add_argument('-db',         required=True,                          help='ko00001.keg')
        stats_ko_parser.add_argument('-o',          required=True,                          help='output directory')
        stats_ko_parser.add_argument('-f',          required=False, action="store_true",    help='force overwrite')
        args = vars(parser.parse_args())
        stats_ko.stats_ko(args)

    elif sys.argv[1] == 'stats_arcog':
        from BioSAK import stats_arcog
        stats_arcog_parser = subparsers.add_parser('stats_arcog', usage=stats_arcog.stats_arcog_usage)
        stats_arcog_parser.add_argument('-cog',         required=True,                          help='cog_ids.txt')
        stats_arcog_parser.add_argument('-db',          required=True,                          help='DB folder, contains arCOGdef.tab and fun-20.tab')
        stats_arcog_parser.add_argument('-o',           required=True,                          help='output directory')
        stats_arcog_parser.add_argument('-f',           required=False, action="store_true",    help='force overwrite')
        args = vars(parser.parse_args())
        stats_arcog.stats_arcog(args)

    elif sys.argv[1] == 'prefix_seq_by_file_name':
        from BioSAK import prefix_seq_by_file_name
        prefix_seq_by_file_name_parser = subparsers.add_parser('prefix_seq_by_file_name', usage=prefix_seq_by_file_name.prefix_seq_by_file_name_usage)
        prefix_seq_by_file_name_parser.add_argument('-i',         required=True,                         help='input sequence folder')
        prefix_seq_by_file_name_parser.add_argument('-x',         required=False, default='fasta',       help='file extension, default: fasta')
        prefix_seq_by_file_name_parser.add_argument('-o',         required=True,                         help='output folder')
        args = vars(parser.parse_args())
        prefix_seq_by_file_name.prefix_seq_by_file_name(args)

    elif sys.argv[1] == 'Combine_KEGG_arCOG':
        from BioSAK import Combine_KEGG_arCOG
        Combine_KEGG_arCOG_parser = subparsers.add_parser('Combine_KEGG_arCOG', usage=Combine_KEGG_arCOG.Combine_KEGG_arCOG_usage)
        Combine_KEGG_arCOG_parser.add_argument('-o',        required=True,                          help='output directory')
        Combine_KEGG_arCOG_parser.add_argument('-kegg',     required=True,                          help='annotation results from KEGG module')
        Combine_KEGG_arCOG_parser.add_argument('-arcog',    required=True,                          help='annotation results from arCOG module')
        Combine_KEGG_arCOG_parser.add_argument('-f',        required=False, action="store_true",    help='force overwrite')
        args = vars(parser.parse_args())
        Combine_KEGG_arCOG.Combine_KEGG_arCOG(args)

    elif sys.argv[1] == 'Combine_KEGG_COG':
        from BioSAK import Combine_KEGG_COG
        Combine_KEGG_COG_parser = subparsers.add_parser('Combine_KEGG_COG', usage=Combine_KEGG_COG.Combine_KEGG_COG_usage)
        Combine_KEGG_COG_parser.add_argument('-o',      required=True,                          help='output directory')
        Combine_KEGG_COG_parser.add_argument('-kegg',   required=True,                          help='annotation results from KEGG module')
        Combine_KEGG_COG_parser.add_argument('-cog',    required=True,                          help='annotation results from COG module')
        Combine_KEGG_COG_parser.add_argument('-f',      required=False, action="store_true",    help='force overwrite')
        args = vars(parser.parse_args())
        Combine_KEGG_COG.Combine_KEGG_COG(args)

    elif sys.argv[1] == 'UNITE_for_BLCA':
        from BioSAK import UNITE_for_BLCA
        UNITE_for_BLCA_parser = subparsers.add_parser('UNITE_for_BLCA', usage=UNITE_for_BLCA.UNITE_for_BLCA_usage)
        UNITE_for_BLCA_parser.add_argument('-i', required=True, help='sh_general_release_dynamic_04.04.2024.fasta')
        args = vars(parser.parse_args())
        UNITE_for_BLCA.UNITE_for_BLCA(args)

    elif sys.argv[1] == 'sra':
        from BioSAK import sra
        sra_parser = subparsers.add_parser('sra', usage=sra.sra_usage)
        sra_parser.add_argument('-i',       required=True,                          help='id')
        sra_parser.add_argument('-o',       required=True,                          help='output directory')
        sra_parser.add_argument('-t',       required=False, type=int, default=1,    help='number of threads, default is 1')
        sra_parser.add_argument('-maxsize', required=False, default='20G',          help='--max-size for prefetch, default is 20G')
        sra_parser.add_argument('-dump',    required=False, action="store_true",    help='run fasterq-dump')
        sra_parser.add_argument('-f',       required=False, action="store_true",    help='force overwrite')
        args = vars(parser.parse_args())
        sra.sra(args)

    elif sys.argv[1] == 'vis_color_scheme':
        from BioSAK import vis_color_scheme
        vis_color_scheme_parser = subparsers.add_parser('vis_color_scheme', usage=vis_color_scheme.vis_color_scheme_usage)
        vis_color_scheme_parser.add_argument('-i', required=True,                           help='lineage file')
        vis_color_scheme_parser.add_argument('-c', required=True,                           help='taxon color file')
        vis_color_scheme_parser.add_argument('-x', required=False, type=int, default=42,    help='plot width, default is 42')
        vis_color_scheme_parser.add_argument('-y', required=False, type=int, default=22,    help='plot height, default is 22')
        vis_color_scheme_parser.add_argument('-o', required=True,                           help='output pdf')
        args = vars(parser.parse_args())
        vis_color_scheme.vis_color_scheme(args)

    elif sys.argv[1] == 'trim':
        from BioSAK import trim
        trim_parser = subparsers.add_parser('trim', usage=trim.trim_usage)
        trim_parser.add_argument('-1',              required=True,                          help='fastq R1')
        trim_parser.add_argument('-2',              required=True,                          help='fastq R2')
        trim_parser.add_argument('-x',              required=True,                          help='file extension, e.g., fastq or fastq.gz')
        trim_parser.add_argument('-a',              required=True,                          help='adapter file, e.g., TruSeq3-PE-2.fa')
        trim_parser.add_argument('-leading',        required=False, type=int, default=25,   help='leading, default is 25')
        trim_parser.add_argument('-trailing',       required=False, type=int, default=25,   help='trailing, default is 25')
        trim_parser.add_argument('-crop',           required=False, type=int, default=145,  help='crop, default is 145')
        trim_parser.add_argument('-headcrop',       required=False, type=int, default=5,    help='headcrop, default is 5')
        trim_parser.add_argument('-swl',            required=False, type=int, default=5,    help='slidingwindow length, default is 5')
        trim_parser.add_argument('-swq',            required=False, type=int, default=25,   help='slidingwindow q-value, default is 25')
        trim_parser.add_argument('-minlen',         required=False, type=int, default=36,   help='minlen, default is 36')
        trim_parser.add_argument('-qci',            required=False, action="store_true",    help='specify to run fastqc for input files')
        trim_parser.add_argument('-qco',            required=False, action="store_true",    help='specify to run fastqc for output files')
        args = vars(parser.parse_args())
        trim.trim(args)

    elif sys.argv[1] == 'FasterqDump':
        from BioSAK import FasterqDump
        FasterqDump_parser = subparsers.add_parser('FasterqDump', usage=FasterqDump.FasterqDump_usage)
        FasterqDump_parser.add_argument('-i',       required=True,                          help='sra directory')
        FasterqDump_parser.add_argument('-x',       required=False,default='sra',           help='sra directory, default is sra')
        FasterqDump_parser.add_argument('-o',       required=True,                          help='output directory')
        FasterqDump_parser.add_argument('-f',       required=False, action="store_true",    help='force overwrite')
        FasterqDump_parser.add_argument('-gzip',    required=False, action="store_true",    help='compress with gzip')
        args = vars(parser.parse_args())
        FasterqDump.FasterqDump(args)

    elif sys.argv[1] == 'abd':
        from BioSAK import abd
        abd_parser = subparsers.add_parser('abd', usage=abd.abd_usage)
        abd_parser.add_argument('-i',           required=True,                          help='input txt')
        abd_parser.add_argument('-r',           required=True,                          help='reference, need to be masked if you do not specify -mask')
        abd_parser.add_argument('-o',           required=True,                          help='output directory')
        abd_parser.add_argument('-rename',      required=False, default=None,           help='rename genome id in the final dataframe')
        abd_parser.add_argument('-keep_bam',    required=False, action="store_true",    help='do not delete bam file')
        abd_parser.add_argument('-t',           required=False, type=int, default=1,    help='number of threads, default is 1')
        abd_parser.add_argument('-f',           required=False, action="store_true",    help='force overwrite')
        args = vars(parser.parse_args())
        abd.abd(args)

    elif sys.argv[1] == 'abd_mask':
        from BioSAK import abd_mask
        abd_mask_parser = subparsers.add_parser('abd_mask', usage=abd_mask.abd_mask_usage)
        abd_mask_parser.add_argument('-i', required=True,                               help='sequence folder')
        abd_mask_parser.add_argument('-x', required=True,                               help='sequence file extension')
        abd_mask_parser.add_argument('-o', required=True,                               help='output directory')
        abd_mask_parser.add_argument('-p', required=False, default='renamed_combined',  help='output prefix, default is renamed_combined')
        abd_mask_parser.add_argument('-t', required=False, type=int, default=1,         help='number of threads, default is 1')
        abd_mask_parser.add_argument('-f', required=False, action="store_true",         help='force overwrite')
        args = vars(parser.parse_args())
        abd_mask.abd_mask(args)

    elif sys.argv[1] == 'mmseqs':
        from BioSAK import mmseqs
        mmseqs_parser = subparsers.add_parser('mmseqs', usage=mmseqs.mmseqs_usage)
        mmseqs_parser.add_argument('-i',    required=True,                          help='sequence file')
        mmseqs_parser.add_argument('-o',    required=True,                          help='output directory')
        mmseqs_parser.add_argument('-db',   required=True,                          help='db dir')
        mmseqs_parser.add_argument('-t',    required=False, type=int, default=1,    help='number of threads, default is 1')
        mmseqs_parser.add_argument('-f',    required=False, action="store_true",    help='force overwrite')
        args = vars(parser.parse_args())
        mmseqs.mmseqs(args)

    elif sys.argv[1] == 'Usearch16S':
        from BioSAK import Usearch16S
        Usearch16S_parser = subparsers.add_parser('Usearch16S', usage=Usearch16S.Usearch16S_usage)
        Usearch16S_parser.add_argument('-i',       required=True,                        help='path to input sequences')
        Usearch16S_parser.add_argument('-x',       required=True,                        help='file extension')
        Usearch16S_parser.add_argument('-o',       required=True,                        help='output directory')
        Usearch16S_parser.add_argument('-l',       required=False,                       help='allowed length range, default is 0-9999')
        Usearch16S_parser.add_argument('-r',       required=False,                       help='reference sequences')
        Usearch16S_parser.add_argument('-blca',    required=False, action="store_true",  help='perform classification with BLCA')
        Usearch16S_parser.add_argument('-c',       required=False,                       help='reference sequence taxonomy')
        Usearch16S_parser.add_argument('-t',       required=False, type=int, default=1,  help='number of threads, default is 1')
        Usearch16S_parser.add_argument('-f',       required=False, action="store_true",  help='force overwrite')
        args = vars(parser.parse_args())
        Usearch16S.Usearch16S(args)

    elif sys.argv[1] == 'rename_df_row':
        from BioSAK import rename_df_row
        rename_df_row_parser = subparsers.add_parser('rename_df_row', usage=rename_df_row.rename_df_row_usage)
        rename_df_row_parser.add_argument('-i',             required=True,                          help='input dataframe')
        rename_df_row_parser.add_argument('-r',             required=True,                          help='rename file, tab separated')
        rename_df_row_parser.add_argument('-o',             required=True,                          help='output dataframe')
        rename_df_row_parser.add_argument('-skip_top_row',  required=False, action="store_true",    help='skip the first row')
        args = vars(parser.parse_args())
        rename_df_row.rename_df_row(args)

    elif sys.argv[1] == 'blca':
        from BioSAK import blca
        blca_parser = subparsers.add_parser('blca', usage=blca.blca_usage)
        blca_parser.add_argument('-i',  required=True,                              help='path to input sequences (in multi-fasta format)')
        blca_parser.add_argument('-x',  required=False,                             help='file extension')
        blca_parser.add_argument('-o',  required=True,                              help='output directory')
        blca_parser.add_argument('-r',  required=True,                              help='reference sequences')
        blca_parser.add_argument('-c',  required=True,                              help='reference taxonomy')
        blca_parser.add_argument('-t',  required=False, type=int, default=1,        help='number of threads')
        blca_parser.add_argument('-f',  required=False, action="store_true",        help='force overwrite')
        args = vars(parser.parse_args())
        blca.blca(args)

    elif sys.argv[1] == 'blast':
        from BioSAK import blast
        blast_parser = subparsers.add_parser('blast', usage=blast.blast_usage)
        blast_parser.add_argument('-i',      required=True,                          help='input file')
        blast_parser.add_argument('-o',      required=True,                          help='output file')
        blast_parser.add_argument('-n',      required=False,type=int, default=9999,  help='top hits to keep, default is all')
        blast_parser.add_argument('-iden',   required=False,type=float, default=80,  help='minimum identity, default is 80')
        blast_parser.add_argument('-cov',    required=False,type=float, default=50,  help='minimum coverage, default is 50')
        blast_parser.add_argument('-tax',    required=False, default=None,           help='NCBI taxonomy file')
        args = vars(parser.parse_args())
        blast.blast(args)

    elif sys.argv[1] == 'taxdump':
        from BioSAK import taxdump
        taxdump_parser = subparsers.add_parser('taxdump', usage=taxdump.taxdump_usage)
        taxdump_parser.add_argument('-node',    required=True, help='nodes.dmp')
        taxdump_parser.add_argument('-name',    required=True, help='names.dmp')
        taxdump_parser.add_argument('-o',       required=True, help='output file')
        args = vars(parser.parse_args())
        taxdump.taxdump(args)

    elif sys.argv[1] == 'rm_low_abd_otu':
        from BioSAK import rm_low_abd_otu
        rm_low_abd_otu_parser = subparsers.add_parser('rm_low_abd_otu', usage=rm_low_abd_otu.rm_low_abd_otu_usage)
        rm_low_abd_otu_parser.add_argument('-i', required=True,                                 help='input otu count table')
        rm_low_abd_otu_parser.add_argument('-c', required=False, default=0.001, type=float,     help='relative abundance cutoff, default is 0.001')
        rm_low_abd_otu_parser.add_argument('-o', required=True,                                 help='output otu count table')
        args = vars(parser.parse_args())
        rm_low_abd_otu.rm_low_abd_otu(args)

    elif sys.argv[1] == 'get_eu_otu':
        from BioSAK import get_eu_otu
        get_eu_otu_parser = subparsers.add_parser('get_eu_otu', usage=get_eu_otu.get_eu_otu_usage)
        get_eu_otu_parser.add_argument('-i',    required=True,                              help='blast result, outfmt need to be 6')
        get_eu_otu_parser.add_argument('-o',    required=True,                              help='output of identified eukaryotic OTUs')
        get_eu_otu_parser.add_argument('-node', required=True,                              help='nodes.dmp ')
        get_eu_otu_parser.add_argument('-db',   required=True,                              help='RefSeq taxonomy file')
        get_eu_otu_parser.add_argument('-c',    required=False, type=float, default=0.3,    help='consider as eukaryotic if the proportion of eukaryotic hits higher than this cutoff, default is 0.3')
        get_eu_otu_parser.add_argument('-n',    required=False, type=int, default=10,       help='number of top hits to consider, default is 10')
        args = vars(parser.parse_args())
        get_eu_otu.get_eu_otu(args)

    elif sys.argv[1] == 'rm_low_depth_sample':
        from BioSAK import rm_low_depth_sample
        rm_low_depth_sample_parser = subparsers.add_parser('rm_low_depth_sample', usage=rm_low_depth_sample.rm_low_depth_sample_usage)
        rm_low_depth_sample_parser.add_argument('-i', required=True,                            help='input otu count table')
        rm_low_depth_sample_parser.add_argument('-c', required=False, default=20000,type=int,   help='minimal number of sequences, default is 20000')
        rm_low_depth_sample_parser.add_argument('-o', required=True,                            help='output otu count table')
        args = vars(parser.parse_args())
        rm_low_depth_sample.rm_low_depth_sample(args)

    elif sys.argv[1] == 'combine_low_abd_otu':
        from BioSAK import combine_low_abd_otu
        combine_low_abd_otu_parser = subparsers.add_parser('combine_low_abd_otu', usage=combine_low_abd_otu.combine_low_abd_otu_usage)
        combine_low_abd_otu_parser.add_argument('-i', required=True,                            help='input otu count table')
        combine_low_abd_otu_parser.add_argument('-c', required=False, default=0.5, type=float,  help='relative abundance cutoff, default is 0.5')
        combine_low_abd_otu_parser.add_argument('-s', required=False, default=None,             help='interested sample txt')
        combine_low_abd_otu_parser.add_argument('-o', required=True,                            help='output otu count table')
        args = vars(parser.parse_args())
        combine_low_abd_otu.combine_low_abd_otu(args)

    elif sys.argv[1] == 'GenBank':
        from BioSAK import GenBank
        GenBank_parser = subparsers.add_parser('GenBank', usage=GenBank.GenBank_usage)
        GenBank_parser.add_argument('-i',   required=True,                       help='input txt containing accession id')
        GenBank_parser.add_argument('-o',   required=True,                       help='output dir')
        GenBank_parser.add_argument('-tax', required=False, default=None,        help='NCBI taxonomy file, specify to get the full taxon lineage')
        GenBank_parser.add_argument('-f',   required=False, action="store_true", help='force overwrite')
        args = vars(parser.parse_args())
        GenBank.GenBank(args)

    else:
        print('Unrecognized module: %s, program exited' % sys.argv[1])
        exit()


upload_to_pypi_cmd = '''

cd /Users/songweizhi/PycharmProjects/BioSAK
rm -r build dist BioSAK.egg-info
python3 setup.py sdist bdist_wheel
twine upload dist/*

__token__

pip3 install --upgrade BioSAK        

'''
